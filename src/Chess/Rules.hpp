#ifndef CHESS_RULES_HPP
#  define CHESS_RULES_HPP

#  include "Chess/Move.hpp"
#  include <vector>

//! \brief Game status. When the game status is different from Playing
//! that means the game has ended and for example: -- GUI should stop accepting
//! moving pieces from user mouse clicks; -- disable communication with other
//! chess engines.
enum Status { Playing, WhiteWon, BlackWon, Stalemate, NoMoveAvailable, /*FIXME a separer*/ InternalError };

//! \brief Give this information to the Rules class if you desired no Kings on the chessboard.
//! This violates the chess rules but is useful for neural network trainings or unit tests.
constexpr bool WithNoKings = true;

//! \brief Give this information to the Rules class for playing official chess rules with Kings
//! This is the default behavior.
constexpr bool WithKings = false;

//! \brief Print the game status.
std::ostream& operator<<(std::ostream& os, const Status& s);

// ***********************************************************************************************
//! \brief Structure storing the piece position on the board and all movements.
//! This structure can be used by other classes.
// ***********************************************************************************************
class Rules // TODO add Kings positions, add number of pieces
{
public:

  Rules();

  Rules(std::string const& fen);

  Rules(const chessboard &board, const Color side = Color::White,
        bool noking = WithKings, Castle wcastle = Castle::Both,
        Castle bcastle = Castle::Both, uint8_t ep = OOB);

  //! \brief Load a chessboard from a given board and a list of legal moves.
  bool load(const std::string& moves, const bool init_board);

  //! \brief Load a chessboard from a string using the Forsyth-Edwards Notation
  bool load(std::string const& fen);

  //! \brief Save a chessboard into a string using the Forsyth-Edwards Notation
  //std::string export();

  //! \brief Generate a list of pseudo legal moves.
  //! The result is stored in m_pseudo_moves.
  const std::vector<Move>& generatePseudoValidMoves();

  //! \brief Generate a list of legal moves from m_pseudo_moves.
  //! The result is stored in m_legal_moves.
  const std::vector<Move>& generateValidMoves();

  //! \brief Display on std::cout all legal moves generated by
  //! generateValidMoves(). To be used for debuging.
  void dispLegalMoves() const;

  //! \brief Display on std::cout all pseudo legal moves generated
  //! by generateValidMoves(). To be used for debuging.
  void dispPseudoMoves() const;

  //! \brief Check in m_pseudo_moves if the given move is found.
  //! If true the move is valid.
  bool isValidMove(std::string const& move) const;

  //! \brief update all states with a new valid move.
  bool applyMove(std::string const& move);

  //! \brief move back the last move (if any).
  //! This method will revert applyMove().
  void revertLastMove();

  //! \brief Check if the King is in check.
  bool isKingInCheck(chessboard const& board, const Color side) const;

  //! \brief Return the game status (checkmate, playing ...).
  //! The status is computed by updateGameStatus() once for
  //! each moves to avoid useless computations.
  Status status() const { return m_status; }

  //! \brief
  //inline void sidePlayed() { m_side = opposite(m_side); }

private:

  //! \brief Load a chessboard from a string using the Forsyth-Edwards Notation
  bool import(std::string const& fen);

  //! \brief Refresh the chessboard with a new move.
  //! \param move shall be a valid move.
  void updateBoard(Move const& move, chessboard& board) const;

  //! \brief Generate a list of pseudo legal of pawn moves.
  void generatePseudoLegalPawnMove(const uint8_t from, const PieceType pt);

  //! \brief Generate a list of pseudo legal of pieces moves.
  void generatePseudoLegalPieceMove(const uint8_t from, const PieceType pt);

  //! \brief Generate a list of pseudo legal of castle moves.
  void generatePseudoLegalCastleMove();

  //! \brief update all states with a new valid move.
  void applyMove(Move const& move);

  //! \brief From a given pseudo legal move, check if it's a
  //! legal move or not.
  bool tryMove(const Move move) const;

  //! \brief From a given position, check if the square sq is attacked by a piece of the
  //! opponent side of side.
  bool attack(const chessboard& position, const uint8_t sq, const Color side) const;

  //! \brief Update the game status (checkmate, playing ...)
  void updateGameStatus();

public: // FIXME should be private but ok because the class is used as const

  //! \brief get the status of the game (check mat, pat)
  Status                m_status;
  //! \brief The Indicate which player can move.
  Color                 m_side;
  //! \brief Save the list of moves which made m_board.
  std::string           m_moved;//FIXME: a renommer
  //! \brief List of pseudo legal moves from m_board.
  std::vector<Move>     m_pseudo_moves;
  //! \brief List of legal moves from m_board.
  std::vector<Move>     m_legal_moves;
  //! \brief Current pieces positions after playing all moves stored in m_moved.
  chessboard            m_board;

  bool hasNoKing;
  uint8_t m_ep;
  uint8_t m_castle[2];
};

#endif
