#ifndef CHESS_RULES_HPP
#  define CHESS_RULES_HPP

#  include "Chess/Board.hpp" // FIXME FEN.hpp
#  include <string>
#  include <vector>

//! \brief Print the type of piece.
enum Castle { NoCastle, Little, Big };

//! \brief Game status. When the game status is different from Playing
//! that means the game has ended and for example: -- GUI should stop accepting
//! moving pieces from user mouse clicks; -- disable communication with other
//! chess engines.
enum Status { Playing, WhiteWon, BlackWon, Stalemate, NoMoveAvailable, /*FIXME a separer*/ InternalError };

//! \brief Give this information to the Rules class if you desired no Kings on the chessboard.
//! This violates the chess rules but is useful for neural network trainings or unit tests.
constexpr bool WithNoKings = true;

//! \brief Give this information to the Rules class for playing official chess rules with Kings
//! This is the default behavior.
constexpr bool WithKings = false;

//! \brief Print the game status.
std::ostream& operator<<(std::ostream& os, const Status& s);

// ***********************************************************************************************
//! \brief
// ***********************************************************************************************
struct Move
{
public:

  Move(const std::string move)
  {
    from = ('8' - move[1]) * 8 + move[0] - 'a';
    to = ('8' - move[3]) * 8 + move[2] - 'a';
    piece = NoPiece;
    promote = false;
    castle = Castle::NoCastle;
    ep = false;
    check = false;
  }

  Move(const uint8_t f, const uint8_t t, const bool e = false)
  {
    from = f;
    to = t;
    piece = NoPiece; // FIXME (false == e) ? NoPiece : position du pion pris;
    promote = false;
    castle = Castle::NoCastle;
    ep = e;
    check = false;
  }

  Move(const uint8_t f, const uint8_t t, const Piece p)
  {
    from = f;
    to = t;
    piece = p;
    promote = true;
    castle = Castle::NoCastle;
    ep = false;
    check = false;
  }

  Move(const Castle c, const Color color)
  {
    piece = WhiteKing;
    piece.color = color;
    promote = false;
    castle = c;
    ep = false;
    check = false;
  }

  inline bool operator==(Move const &other) const
  {
    return (from == other.from) && (to == other.to);
  }

  uint8_t from;
  uint8_t to;
  Piece   piece;
  struct
  {
    unsigned int castle        : 2; // enum Casttle
    unsigned int promote       : 1; // See Piece for promotion
    unsigned int ep            : 1; // En passant move
    unsigned int check         : 1; // King check
    unsigned int piece_moved   : 3;
  };
};

//! \brief
std::string Move2str(const Move move);
std::string Move2str(const uint8_t sq);
std::string Move2str(const uint8_t from, const uint8_t to);

//! \brief Pretty print a move note.
std::ostream& operator<<(std::ostream& os, const Move& m);

// ***********************************************************************************************
//! \brief Structure storing the piece position on the board and all movements.
//! This structure can be used by other classes.
// ***********************************************************************************************
class Rules // TODO add Kings positions, add number of pieces
{
public:

  Rules(const Color side = Color::White,
        const chessboard &board = Chessboard::Init,
        bool noking = WithKings)
    : m_status(Status::Playing),
      m_side(side),
      m_board(board),
      m_tmp_board(board),
      hasNoKing(noking)
  {
    generateValidMoves();
  }

  //! \brief Check if the given move is valid.
  bool isValidMove(const Move move) const;

  //! \brief Generate a list of legal moves. The result is stored in m_legal_moves.
  Status generateValidMoves();

  //! \brief Display on std::cout all legal moves generated by generateValidMoves().
  void dispLegalMoves() const;

  //! \brief Move a piece.
  void makeMove(const std::string& next_move);

  //! \brief Move a piece.
  inline void makeMove(const char *m) { makeMove(std::string(m)); }

  //! \brief Revert the last move (if any).
  void moveBack();

  void loadPosition(const std::string& moves);
  void loadPosition(const chessboard& board);

  //! \brief
  inline void sidePlayed()
  {
    m_side = (Color::White == m_side ? Color::Black : Color::White);
  }

  //! \brief
  Status getStatus() const;

  //! \brief
  bool inCheck(const Color side) const;

private:

  //! \brief From a given pseudo legal move, check if it's a legal move and if yes,
  //! store it in m_legal_moves.
  bool tryMove(const Move move, const Color side);

  //! \brief From a given position, check if the square sq is attacked by a piece of the
  //! opponent side of side.
  bool attack(const std::array<Piece, 64>& position, const uint8_t sq, const Color side) const;

public: // FIXME should be private but ok because the class is used as const

  //! \brief get the status of the game (check mat, pat)
  Status                m_status;
  //! \brief The Indicate which player can move.
  Color                 m_side;
  //! \brief Save the list of moves which made m_board.
  std::string           m_moved;
  //! \brief List of legal moves from m_board.
  std::vector<Move>     m_legal_moves;
  //! \brief Current pieces positions after playing all moves stored in m_moved.
  chessboard            m_board;
  //! \brief Temporary board for computations.
  chessboard            m_tmp_board;

  bool hasNoKing;
};

#endif
