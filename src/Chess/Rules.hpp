//=====================================================================
// ChessNeuNeu: Non serious chess engine for learning neural networks.
// Copyright 2018 Quentin Quadrat <lecrapouille@gmail.com>
//
// This file is part of ChessNeuNeu.
//
// ChessNeuNeu is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
//=====================================================================

#ifndef CHESS_RULES_HPP
#  define CHESS_RULES_HPP

#  include "Chess/Move.hpp"
#  include <vector>

//! \brief Game status. When the game status is different from Playing
//! that means the game has ended and for example: -- GUI should stop accepting
//! moving pieces from user mouse clicks; -- disable communication with other
//! chess engines.
enum Status { Playing, WhiteWon, BlackWon, Stalemate, NoMoveAvailable, /*FIXME a separer*/ InternalError };

//! \brief Give this information to the Rules class if you desired no Kings on the chessboard.
//! This violates the chess rules but is useful for neural network trainings or unit tests.
constexpr bool WithNoKings = true;

//! \brief Give this information to the Rules class for playing official chess rules with Kings
//! This is the default behavior.
constexpr bool WithKings = false;

//! \brief Print the game status.
std::ostream& operator<<(std::ostream& os, const Status& s);

// ***********************************************************************************************
//! \brief Initial chessboard (loaded with FEN) used for reverting moves.
// ***********************************************************************************************
struct Initial
{
  chessboard  board;
  uint8_t     ep;
  uint8_t     castle[2];
  Color       side;
};

// ***********************************************************************************************
//! \brief Structure storing the piece position on the board and all movements.
//! This structure can be used by other classes.
// ***********************************************************************************************
class Rules // TODO add Kings positions, add number of pieces
{
public:

  Rules();

  Rules(std::string const& fen);

  Rules(const chessboard &board, const Color side = Color::White,
        bool noking = WithKings, Castle wcastle = Castle::Both,
        Castle bcastle = Castle::Both, uint8_t ep = OOB);

  //! \brief Load a chessboard from a given board and a list of legal moves.
  bool applyMoves(std::string const& moves, bool const init_board);

  //! \brief Load a chessboard from a string using the Forsyth-Edwards Notation
  bool load(std::string const& fen);

  //! \brief Save a chessboard into a string using the Forsyth-Edwards Notation
  //std::string export();

  //! \brief Generate a list of pseudo legal moves.
  //! The result is stored in m_pseudo_moves.
  const std::vector<Move>& generatePseudoValidMoves();

  //! \brief Generate a list of legal moves from m_pseudo_moves.
  //! The result is stored in m_legal_moves.
  const std::vector<Move>& generateValidMoves();

  //! \brief Display on std::cout all legal moves generated by
  //! generateValidMoves(). To be used for debuging.
  void dispLegalMoves() const;

  //! \brief Display on std::cout all pseudo legal moves generated
  //! by generateValidMoves(). To be used for debuging.
  void dispPseudoMoves() const;

  //! \brief Check in m_pseudo_moves if the given move is found.
  //! If true the move is valid.
  bool isValidMove(std::string const& move) const;

  //! \brief update all states with a new valid move.
  bool applyMove(std::string const& move);

  //! \brief move back the last move (if any).
  //! This method will revert applyMove().
  std::string revertLastMove();

  //! \brief Check if the King is in check.
  bool isKingInCheck(chessboard const& board, const Color side) const;

  //! \brief Return the game status (checkmate, playing ...).
  //! The status is computed by updateGameStatus() once for
  //! each moves to avoid useless computations.
  Status status() const { return m_status; }

  //! \brief
  //inline void sidePlayed() { m_side = opposite(m_side); }

private:

  //! \brief Load a chessboard from a string using the Forsyth-Edwards Notation
  bool import(std::string const& fen);

  //! \brief Refresh the chessboard with a new move.
  //! \param move shall be a valid move.
  void updateBoard(Move const& move, chessboard& board) const;

  //! \brief Generate a list of pseudo legal of pawn moves.
  void generatePseudoLegalPawnMove(const uint8_t from, const PieceType pt);

  //! \brief Generate a list of pseudo legal of pieces moves.
  void generatePseudoLegalPieceMove(const uint8_t from, const PieceType pt);

  //! \brief Generate a list of pseudo legal of castle moves.
  void generatePseudoLegalCastleMove();

  //! \brief update all states with a new valid move.
  void applyMove(Move const& move);

  //! \brief From a given pseudo legal move, check if it's a
  //! legal move or not.
  bool tryMove(const Move move) const;

  //! \brief From a given position, check if the square sq is attacked by a piece of the
  //! opponent side of side.
  bool attack(const chessboard& position, const uint8_t sq, const Color side) const;

  //! \brief Update the game status (checkmate, playing ...)
  void updateGameStatus();

  //! \brief Save initial chessboard states after loading a FEN.
  void saveStates();

public: // FIXME should be private but ok because the class is used as const

  //! \brief get the status of the game (check mat, pat)
  Status                m_status;
  //! \brief The Indicate which player can move.
  Color                 m_side;
  //! \brief Save the list of moves which made m_board.
  std::string           m_moved;//FIXME: a renommer
  //! \brief List of pseudo legal moves from m_board.
  std::vector<Move>     m_pseudo_moves;
  //! \brief List of legal moves from m_board.
  std::vector<Move>     m_legal_moves;
  //! \brief Current pieces positions after playing all moves stored in m_moved.
  chessboard            m_board;
  //! \brief Set it true for unit tests or neural network and when its allowed to
  //! have no kings in the chessboard (which is not allowed by standard rules).
  bool                  m_no_kings;
  //! \brief Indicate the en-passant square. When possible the value refers to
  //! a chessboard sqaure (enum Square). When not possible, the value is Square::OOB.
  //! This state is updated after moving a piece.
  uint8_t               m_ep; // FIXME: correct type is enum Square
  //! \brief Indicate possible castle sides for each color. When moving pieces this
  //! state is updated.
  uint8_t               m_castle[2]; // FIXME: correct type is OR'ed enum Castle
  //! \brief Save chessboard states after loading FEN position.
  Initial               m_initial;
};

#endif
